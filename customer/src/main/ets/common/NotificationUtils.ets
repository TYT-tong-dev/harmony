// NotificationUtils.ets - é¡¾å®¢ç«¯é€šçŸ¥å·¥å…·ç±»
import notificationManager from '@ohos.notificationManager';
import { BusinessError } from '@ohos.base';
import wantAgent, { WantAgent } from '@ohos.app.ability.wantAgent';
import vibrator from '@ohos.vibrator';
import Want from '@ohos.app.ability.Want';

// é€šçŸ¥ç±»å‹
export enum NotificationType {
  ORDER_STATUS = 'order_status',  // è®¢å•çŠ¶æ€é€šçŸ¥
  SYSTEM = 'system'               // ç³»ç»Ÿé€šçŸ¥
}

// é€šçŸ¥é…ç½®
export class NotificationConfig {
  enableVibrate: boolean = true;
  enableSound: boolean = true;
}

// é€šçŸ¥æ•°æ®
export class NotificationData {
  id: number = 0;
  type: NotificationType = NotificationType.SYSTEM;
  title: string = '';
  content: string = '';
  extra?: Record<string, string>;
  config?: NotificationConfig;
}

// éœ‡åŠ¨æ¨¡å¼
class VibratePatterns {
  static readonly ORDER_STATUS: number = 300;
  static readonly SYSTEM: number = 200;

  static getDuration(type: NotificationType): number {
    if (type === NotificationType.ORDER_STATUS) {
      return VibratePatterns.ORDER_STATUS;
    }
    return VibratePatterns.SYSTEM;
  }
}

// é¡¾å®¢ç«¯é€šçŸ¥å·¥å…·ç±»
export class NotificationUtils {
  private static notificationId: number = 1;
  private static defaultConfig: NotificationConfig = new NotificationConfig();

  // è¯·æ±‚é€šçŸ¥æƒé™
  static async requestPermission(): Promise<boolean> {
    try {
      const isEnabled = await notificationManager.isNotificationEnabled();
      if (isEnabled) {
        console.info('[NotificationUtils] é€šçŸ¥æƒé™å·²å¼€å¯');
        return true;
      }
      console.info('[NotificationUtils] éœ€è¦ç”¨æˆ·æ‰‹åŠ¨å¼€å¯é€šçŸ¥æƒé™');
      return false;
    } catch (error) {
      const err = error as BusinessError;
      console.error('[NotificationUtils] æ£€æŸ¥é€šçŸ¥æƒé™å¤±è´¥: ' + err.message);
      return false;
    }
  }

  // è§¦å‘éœ‡åŠ¨
  private static async triggerVibrate(type: NotificationType): Promise<void> {
    try {
      const duration = VibratePatterns.getDuration(type);
      const vibrateEffect: vibrator.VibrateTime = {
        type: 'time',
        duration: duration
      };
      const vibrateAttr: vibrator.VibrateAttribute = {
        id: 0,
        usage: 'notification'
      };
      await vibrator.startVibration(vibrateEffect, vibrateAttr);
    } catch (error) {
      const err = error as BusinessError;
      console.error('[NotificationUtils] éœ‡åŠ¨è§¦å‘å¤±è´¥: ' + err.message);
    }
  }

  // å‘é€æœ¬åœ°é€šçŸ¥
  static async sendNotification(data: NotificationData): Promise<boolean> {
    try {
      const config = data.config || NotificationUtils.defaultConfig;

      // æ„å»ºå‚æ•°å¯¹è±¡
      const extraParams: Record<string, Object> = {};
      extraParams['notificationType'] = data.type as string;
      extraParams['notificationId'] = data.id.toString();
      if (data.extra) {
        const keys = Object.keys(data.extra);
        for (const key of keys) {
          extraParams[key] = data.extra[key] as Object;
        }
      }

      // åˆ›å»ºWantå¯¹è±¡
      const want: Want = {
        bundleName: 'com.example.h',
        abilityName: 'CustomerAbility',
        parameters: extraParams
      };

      // åˆ›å»ºç‚¹å‡»é€šçŸ¥åçš„è·³è½¬æ„å›¾
      const wantInfo: wantAgent.WantAgentInfo = {
        wants: [want],
        actionType: wantAgent.OperationType.START_ABILITY,
        requestCode: 0,
        wantAgentFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG]
      };

      const agent: WantAgent = await wantAgent.getWantAgent(wantInfo);

      // æ„å»ºé€šçŸ¥è¯·æ±‚
      const notificationRequest: notificationManager.NotificationRequest = {
        id: NotificationUtils.notificationId++,
        content: {
          notificationContentType: notificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
          normal: {
            title: data.title,
            text: data.content
          }
        },
        wantAgent: agent,
        notificationSlotType: config.enableSound
          ? notificationManager.SlotType.SOCIAL_COMMUNICATION
          : notificationManager.SlotType.CONTENT_INFORMATION
      };

      await notificationManager.publish(notificationRequest);
      console.info('[NotificationUtils] å‘é€é€šçŸ¥æˆåŠŸ: ' + data.title);

      // è§¦å‘éœ‡åŠ¨
      if (config.enableVibrate) {
        await NotificationUtils.triggerVibrate(data.type);
      }

      return true;
    } catch (error) {
      const err = error as BusinessError;
      console.error('[NotificationUtils] å‘é€é€šçŸ¥å¤±è´¥: ' + err.message);
      return false;
    }
  }

  // å‘é€è®¢å•çŠ¶æ€é€šçŸ¥
  static async sendOrderStatusNotification(
    orderId: number,
    status: string,
    message: string
  ): Promise<boolean> {
    const notificationData = new NotificationData();
    notificationData.id = orderId;
    notificationData.type = NotificationType.ORDER_STATUS;
    notificationData.title = 'ğŸ“¦ è®¢å•çŠ¶æ€æ›´æ–°';
    notificationData.content = message;
    const extraData: Record<string, string> = {};
    extraData['orderId'] = orderId.toString();
    extraData['status'] = status;
    notificationData.extra = extraData;
    return NotificationUtils.sendNotification(notificationData);
  }

  // å–æ¶ˆé€šçŸ¥
  static async cancelNotification(id: number): Promise<void> {
    try {
      await notificationManager.cancel(id);
    } catch (error) {
      const err = error as BusinessError;
      console.error('[NotificationUtils] å–æ¶ˆé€šçŸ¥å¤±è´¥: ' + err.message);
    }
  }
}

