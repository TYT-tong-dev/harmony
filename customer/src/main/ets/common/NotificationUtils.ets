// NotificationUtils.ets - é¡¾å®¢ç«¯é€šçŸ¥å·¥å…·ç±»
import notificationManager from '@ohos.notificationManager';
import { BusinessError } from '@ohos.base';
import wantAgent, { WantAgent } from '@ohos.app.ability.wantAgent';
import vibrator from '@ohos.vibrator';

// é€šçŸ¥ç±»å‹
export enum NotificationType {
  ORDER_STATUS = 'order_status',  // è®¢å•çŠ¶æ€é€šçŸ¥
  SYSTEM = 'system'               // ç³»ç»Ÿé€šçŸ¥
}

// é€šçŸ¥é…ç½®
export interface NotificationConfig {
  enableVibrate: boolean;
  enableSound: boolean;
}

// é€šçŸ¥æ•°æ®
export interface NotificationData {
  id: number;
  type: NotificationType;
  title: string;
  content: string;
  extra?: Record<string, string>;
  config?: NotificationConfig;
}

// éœ‡åŠ¨æ¨¡å¼
const VIBRATE_PATTERNS: Record<string, number> = {
  order_status: 300,
  system: 200
};

// é¡¾å®¢ç«¯é€šçŸ¥å·¥å…·ç±»
export class NotificationUtils {
  private static notificationId: number = 1;
  private static defaultConfig: NotificationConfig = {
    enableVibrate: true,
    enableSound: true
  };

  // è¯·æ±‚é€šçŸ¥æƒé™
  static async requestPermission(): Promise<boolean> {
    try {
      const isEnabled = await notificationManager.isNotificationEnabled();
      if (isEnabled) {
        console.info('[NotificationUtils] é€šçŸ¥æƒé™å·²å¼€å¯');
        return true;
      }
      console.info('[NotificationUtils] éœ€è¦ç”¨æˆ·æ‰‹åŠ¨å¼€å¯é€šçŸ¥æƒé™');
      return false;
    } catch (error) {
      const err = error as BusinessError;
      console.error('[NotificationUtils] æ£€æŸ¥é€šçŸ¥æƒé™å¤±è´¥: ' + err.message);
      return false;
    }
  }

  // è§¦å‘éœ‡åŠ¨
  private static async triggerVibrate(type: NotificationType): Promise<void> {
    try {
      const duration = VIBRATE_PATTERNS[type] || 200;
      await vibrator.startVibration({
        type: 'time',
        duration: duration
      }, {
        id: 0,
        usage: 'notification'
      });
    } catch (error) {
      const err = error as BusinessError;
      console.error('[NotificationUtils] éœ‡åŠ¨è§¦å‘å¤±è´¥: ' + err.message);
    }
  }

  // å‘é€æœ¬åœ°é€šçŸ¥
  static async sendNotification(data: NotificationData): Promise<boolean> {
    try {
      const config = data.config || NotificationUtils.defaultConfig;

      // åˆ›å»ºç‚¹å‡»é€šçŸ¥åçš„è·³è½¬æ„å›¾
      const wantAgentInfo: wantAgent.WantAgentInfo = {
        wants: [
          {
            bundleName: 'com.example.h',
            abilityName: 'CustomerAbility',
            parameters: {
              notificationType: data.type,
              notificationId: data.id.toString(),
              ...data.extra
            }
          }
        ],
        actionType: wantAgent.OperationType.START_ABILITY,
        requestCode: 0,
        wantAgentFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG]
      };

      const agent: WantAgent = await wantAgent.getWantAgent(wantAgentInfo);

      // æ„å»ºé€šçŸ¥è¯·æ±‚
      const notificationRequest: notificationManager.NotificationRequest = {
        id: NotificationUtils.notificationId++,
        content: {
          notificationContentType: notificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
          normal: {
            title: data.title,
            text: data.content
          }
        },
        wantAgent: agent,
        notificationSlotType: config.enableSound
          ? notificationManager.SlotType.SOCIAL_COMMUNICATION
          : notificationManager.SlotType.CONTENT_INFORMATION
      };

      await notificationManager.publish(notificationRequest);
      console.info('[NotificationUtils] å‘é€é€šçŸ¥æˆåŠŸ: ' + data.title);

      // è§¦å‘éœ‡åŠ¨
      if (config.enableVibrate) {
        await NotificationUtils.triggerVibrate(data.type);
      }

      return true;
    } catch (error) {
      const err = error as BusinessError;
      console.error('[NotificationUtils] å‘é€é€šçŸ¥å¤±è´¥: ' + err.message);
      return false;
    }
  }

  // å‘é€è®¢å•çŠ¶æ€é€šçŸ¥
  static async sendOrderStatusNotification(
    orderId: number,
    status: string,
    message: string
  ): Promise<boolean> {
    return this.sendNotification({
      id: orderId,
      type: NotificationType.ORDER_STATUS,
      title: 'ğŸ“¦ è®¢å•çŠ¶æ€æ›´æ–°',
      content: message,
      extra: {
        orderId: orderId.toString(),
        status: status
      }
    });
  }

  // å–æ¶ˆé€šçŸ¥
  static async cancelNotification(id: number): Promise<void> {
    try {
      await notificationManager.cancel(id);
    } catch (error) {
      const err = error as BusinessError;
      console.error('[NotificationUtils] å–æ¶ˆé€šçŸ¥å¤±è´¥: ' + err.message);
    }
  }
}

